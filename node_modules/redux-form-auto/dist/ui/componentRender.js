"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSkinType = exports.setSkin = exports.renderInputs = exports.renderInput = exports.FieldPropsOverride = exports.components = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _utils = require("../utils");

var _defaultSkin = require("./defaultSkin");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

let components = _defaultSkin.defaultSkin;
/**
 * Allows to specify extra props for a field in runtime.
 */

exports.components = components;

class FieldPropsOverride extends _react.PureComponent {}

exports.FieldPropsOverride = FieldPropsOverride;
FieldPropsOverride.propTypes = {
  name: _propTypes.default.string.isRequired
  /**
   * Searches in children to find overrides.
   */

};

const searchForOverrides = (parent, name, children = []) => {
  const childrenArr = _react.Children.map(children, child => child);

  return childrenArr.reduce((override, child) => {
    const childName = child.props.name;
    const compositeName = parent ? `${parent}.${name}` : name;
    if (child.type == FieldPropsOverride && compositeName == childName) return child.props;else return override;
  }, {});
};
/**
 * Renders a single field.
 *
 * @param {object} params
 * @param {string} params.field Name of the field
 * @param {object} params.fieldSchema Schema specification
 *    for the field
 * @param {string} params.parent Prefix of the field name
 * @param {string} params.schemaTypeName Name of the schema
 *    (first argument while instantiating a schema)
 * @param {object} params.config Form configuration
 * @param {...object} params.rest props passed to the component
 */


const renderInput = (_ref) => {
  let {
    field,
    fieldSchema,
    fieldSchema: {
      type,
      required
    },
    parent,
    containerField,
    propOverrides,
    schemaTypeName,
    config = {}
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["field", "fieldSchema", "fieldSchema", "parent", "containerField", "propOverrides", "schemaTypeName", "config"]);

  const strType = (0, _utils.schemaTypeEx)(type);
  const control = components[strType];

  if (control) {
    const Component = control.component;
    const useField = parent ? `${parent}.${field}` : field;

    const baseProps = _objectSpread({
      key: useField,
      name: useField,
      field,
      fieldSchema,
      schemaTypeName,
      config,
      containerField,
      propOverrides
    }, rest, searchForOverrides(containerField, useField, propOverrides));

    const {
      props
    } = control;
    let componentProps;
    if (typeof props == 'function') componentProps = props ? props(baseProps) : baseProps;else componentProps = _objectSpread({}, baseProps, props);
    return _react.default.createElement(Component, componentProps);
  } else return null;
};
/**
 * Renders the inputs to make the schema work.
 *
 * @param {object} params
 * @param {Schema} params.schema Schema instance
 * @param {object} params.config Rendering configuration
 * @param {string} params.config.arrayMode 'panels' or 'table'
 * @param {boolean} params.config.horizontal Labels above inputs
 * @param {...object} params.rest Props passed to each input
 *
 * @returns {array} React elements with the form and inputs.
 */


exports.renderInput = renderInput;

const renderInputs = (_ref2) => {
  let {
    schema,
    config = {},
    children,
    propOverrides
  } = _ref2,
      rest = _objectWithoutProperties(_ref2, ["schema", "config", "children", "propOverrides"]);

  const schemaDef = schema.getSchema();
  const schemaKeys = Object.keys(schemaDef);
  return schemaKeys.map(field => renderInput(_objectSpread({}, rest, {
    field,
    config,
    propOverrides: propOverrides || children,
    fieldSchema: schemaDef[field],
    schemaTypeName: schema.getType()
  })));
};
/**
 * Sets the whole skin at once.
 *
 * @param {object} skin Whole skin description
 */


exports.renderInputs = renderInputs;

const setSkin = skin => {
  exports.components = components = skin;
};
/**
 * Sets the rendering for a specific schema type.
 *
 * @param {string} typeName Type name as it appears
 *    in the schema specification.
 * @param {skinTypeMap} rendering Object with the
 *    rendering specification.
 */


exports.setSkin = setSkin;

const addSkinType = (typeName, rendering) => {
  components[typeName] = rendering;
};

exports.addSkinType = addSkinType;