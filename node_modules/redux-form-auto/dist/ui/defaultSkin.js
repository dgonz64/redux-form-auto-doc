"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultSkin = void 0;

var components = _interopRequireWildcard(require("./components/index"));

var _InputWrap = require("./wrappers/InputWrap");

var _InputArrayWrap = require("./wrappers/InputArrayWrap");

var _InputArrayPanel = require("./components/InputArrayPanel");

var _InputArrayTable = require("./components/InputArrayTable");

var _BSInputWrapper = require("./components/BSInputWrapper");

var _componentRender = require("./componentRender");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Data brick used to create a component for a type.
 *
 * @typedef {object} skinTypeMap
 * @property {Component} component
 * @property {function|object} props
 */
const defaultSkin = {
  form: {
    component: components.Form,
    props: {}
  },
  string: {
    component: _InputWrap.InputWrap,
    props: {
      inputWrapper: _BSInputWrapper.BSInputWrapper,
      inputComponent: 'input'
    }
  },
  number: {
    component: _InputWrap.InputWrap,
    props: {
      inputWrapper: _BSInputWrapper.BSInputWrapper,
      inputComponent: 'input',
      type: 'number',
      parse: value => Number(value)
    }
  },
  array: {
    component: _InputArrayWrap.InputArrayWrap,
    props: props => {
      const {
        config = {},
        propOverrides,
        fieldSchema: {
          type
        },
        name
      } = props;
      const {
        arrayMode
      } = config;
      const arrayHandler = arrayMode == 'table' ? _InputArrayTable.InputArrayTable : _InputArrayPanel.InputArrayPanel;
      return _objectSpread({}, props, {
        arrayHandler,
        children: (0, _componentRender.renderInputs)({
          schema: type[0],
          config,
          propOverrides,
          containerField: name
        })
      });
    }
  },
  schema: {
    component: components.Submodel
  },
  select: {
    component: _InputWrap.InputWrap,
    props: props => {
      const {
        fieldSchema: {
          options
        },
        schemaTypeName,
        name
      } = props;
      return _objectSpread({}, props, {
        inputWrapper: _BSInputWrapper.BSInputWrapper,
        inputComponent: 'select',
        children: components.mapSelectOptions(schemaTypeName, name, options)
      });
    }
  },
  radios: {
    component: _InputWrap.InputWrap,
    props: props => {
      return _objectSpread({}, props, {
        inputWrapper: _BSInputWrapper.BSInputWrapper,
        inputComponent: components.Radio,
        children: components.mapRadioOptions(props)
      });
    }
  },
  boolean: {
    component: _InputWrap.InputWrap,
    props: props => _objectSpread({}, props, {
      inputWrapper: _BSInputWrapper.BSInputWrapper,
      inputComponent: components.Checkbox,
      labelOverride: ''
    })
  }
};
exports.defaultSkin = defaultSkin;