"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addValidator = exports.testFactory = exports.errorReport = exports.specialTypes = void 0;

var _schema = require("./schema");

var _utils = require("./utils");

/**
 * Validation creators for some types.
 */
const specialTypes = {
  integer: value => value && !Number.isInteger(value),
  select: value => value && typeof value != 'string',
  radios: value => value && typeof value != 'string'
  /**
   * Translates ArrayField error for ReduxForm
   *
   * @param {string} kind Error type
   * @param {string} error Error message
   *
   * @returns {object|string} Error message
   */

};
exports.specialTypes = specialTypes;

const errorReport = (kind, error) => {
  switch (kind) {
    case 'minChildren':
    case 'maxChildren':
      return {
        _error: error
      };

    default:
      return error;
  }
};
/**
 * Error creators with the validator factories.
 */


exports.errorReport = errorReport;
const testFactory = {
  type: entry => {
    const {
      type
    } = entry;

    if (type instanceof _schema.Schema) {
      return (value, validationType) => value ? typeof value == 'object' ? type.validateType(value, validationType) : true : false;
    } else if (Array.isArray(type)) {
      const schema = type[0];
      return (value, validationType) => {
        if (value && Array.isArray(value)) {
          return value.map(child => schema.validateType(child, validationType));
        } else return false;
      };
    } else {
      const typeStr = (0, _utils.schemaType)(type);
      const tester = specialTypes[typeStr];
      return value => {
        if (value) {
          if (tester) return tester(value);else return (0, _utils.getType)(value) != typeStr;
        } else return false;
      };
    }
  },
  min: entry => value => value && value.length < entry.min,
  max: entry => value => value && value.length > entry.max,
  required: entry => value => !Boolean(value),
  minChildren: entry => value => !Array.isArray(value) || value.length < (entry.minChildren || 0),
  maxChildren: entry => value => !Array.isArray(value) || entry.maxChildren && value.length > entry.maxChildren,
  validation: entry => value => entry.validation(value, entry),
  accept: entry => value => value ? !entry.accept.test(value) : false,
  reject: entry => value => value && typeof value == 'string' ? entry.reject.test(value) : false,
  options: entry => value => value && entry.options.indexOf(value) == -1
  /**
   * Validator. Accepts a value and returns validation result.
   *
   * @typedef {function} validator
   * @param {any} value Value to be validated
   *
   * @returns {boolean|translatable|string} ``true`` if validation fails.
   *    If it's a string, the value will be printed directly,
   *    untranslated to the input. If the value is an object,
   *    it's considered a translatable.
   */

  /**
   * Creates a specific validator.
   *
   * @typedef {function} validatorConstructor
   * @param {entry} A Schema specification for a field.
   *
   * @returns {validator}
   */

  /**
   * Adds a test creator to the testFactory table, that way you can
   * use your own custom validations.
   *
   * @param {string} validationName The validation name for the
   *    test being created.
   * @param {validatorConstructor} validation Function that takes
   *    the entry and creates a validator to be used later.
   */

};
exports.testFactory = testFactory;

const addValidator = (validationName, validation) => {
  testFactory[validationName] = validation;
};

exports.addValidator = addValidator;