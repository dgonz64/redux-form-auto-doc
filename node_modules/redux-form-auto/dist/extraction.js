"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWarningValidators = exports.createErrorValidators = void 0;

var _schema = require("./schema");

var _validation = require("./validation");

var _utils = require("./utils");

var _validators = require("./validators.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } }

/**
 * Extracts message data based on a validation
 * test in the schema.
 *
 * @param {string} kind Type of the field
 * @param {object} entry 
 *
 * @returns {object} Data for the message translation.
 */
const extractMsgData = (kind, entry) => {
  const data = entry[kind];

  switch (kind) {
    case 'type':
      if (data instanceof _schema.Schema) return {
        [kind]: data.getType()
      };else return {
        [kind]: (0, _utils.schemaType)(data)
      };

    case 'validation':
    case 'accept':
    case 'reject':
      return {};

    default:
      return {
        [kind]: data
      };
  }
};
/**
 * Creates all the needed tests for a configuration
 * block by comparing each attribute with the existing
 * test creators.
 *
 * @param {object} entry Object with the validation tests.
 *
 * @returns {array} All the tests created and ready.
 */


const createTesters = entry => {
  const entryKeys = Object.keys(entry);
  return entryKeys.reduce((tests, kind) => {
    const creator = _validators.testFactory[kind];

    if (creator) {
      const test = creator(entry);
      const msgData = extractMsgData(kind, entry);
      return _toConsumableArray(tests).concat([{
        kind,
        test,
        msgData
      }]);
    } else {
      return tests;
    }
  }, []);
};
/**
 * Extracts an entry or list of entries to generate
 * a flat array with the needed tests already created.
 *
 * @param {object|array} Test block or list of tests blocks
 *    used to generate the validation tests.
 *
 * @returns {array} All the tests created and ready.
 */


const extract = entry => {
  if (entry) {
    const tests = (0, _utils.forceArray)(entry);
    return tests.reduce((tests, entry) => {
      return _toConsumableArray(tests).concat(_toConsumableArray(createTesters(entry)));
    }, []);
  } else {
    return [];
  }
};
/**
 * Extracts just the error validations. That can
 * happen in the same schema block as the field
 * or in an object in the error attribute.
 *
 * @param {object} entry Schema entry.
 *
 * @returns {array} Tests created and ready.
 */


const extractErrorer = entry => {
  return _toConsumableArray(extract(entry)).concat(_toConsumableArray(extract(entry.error)));
};
/**
 * Extracts just the warning block
 */


const extractWarner = entry => extract(entry.warning);
/**
 * Bridge to extract the desired validations.
 *
 * @param {object} schema Schema
 * @param {extractorCallback} extractor Function used
 *    to select what to extract and extract it.
 *
 * @returns {array} Validated tests ready for use.
 */


const extractValidations = (schema, extractor) => {
  const keys = Object.keys(schema);
  return keys.reduce((validators, key) => {
    const entry = schema[key];
    validators[key] = extractor(entry);
    return validators;
  }, {});
};
/**
 * Callback for extracting validation tests.
 *
 * @callback extractorCallback
 * @param {object} entry Schema data
 */

/**
 * Creates the validation code for an schema using
 * a extractor.
 *
 * @param {object} schema Schema data
 * @param {extractorCallback} extractor Select and
 *    extract.
 */


const createValidators = ({
  schema,
  extractor,
  validationType
}) => {
  const validationsByKey = extractValidations(schema, extractor);
  extractor.validationType = validationType;
  return model => {
    const validation = (0, _validation.validate)({
      model,
      validationsByKey,
      validationType
    });
    return validation;
  };
};
/**
 * Extracts only the error validators.
 *
 * @param {object} schema Schema data.
 *
 * @returns {array} Validators
 */


const createErrorValidators = schema => createValidators({
  schema,
  extractor: extractErrorer,
  validationType: 'error'
});
/**
 * Extracts only the warning validators.
 *
 * @param {object} schema Schema data
 */


exports.createErrorValidators = createErrorValidators;

const createWarningValidators = schema => createValidators({
  schema,
  extractor: extractWarner,
  validationType: 'warning'
});

exports.createWarningValidators = createWarningValidators;